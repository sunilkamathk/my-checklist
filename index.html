    <!-- Sync Status -->
    <div class="sync-status" id="syncStatus">üîÑ Syncing with GitHub...</div>
    
    <!-- Date & Time Section -->
    <div class="info-section">
        <div class="datetime">
            <div class="datetime-large" id="currentDate"></div>
            <div id="currentTime"></div>
        </div>
    </div>
    
    <!-- Drag Hint -->
    <div class="drag-hint">
        üí° Tip: Items are automatically sorted alphabetically. Drag items to move between sections. Data syncs across devices!
    </div>
    
    <!-- Add New Category Section -->
    <div class="add-category-section">
        <div class="add-category-title">‚ûï Add New Category</div>
        <div class="add-category-form">
            <input type="text" id="newCategoryName" class="add-category-input" placeholder="Enter category name (e.g., üèñÔ∏è Beach Items)...">
            <button class="add-category-btn" onclick="addNewCategory()">Add Category</button>
        </div>
    </div>
    
    <!-- Add New Item Section -->
    <div class="add-item-section">
        <div class="add-item-title">‚ûï Add New Item</div>
        <div class="add-item-form">
            <input type="text" id="newItemName" class="add-item-input" placeholder="Enter item name...">
            <select id="sectionSelect" class="add-item-select">
                <!-- Options will be populated dynamically -->
            </select>
            <button class="add-item-btn" onclick="addNewItem()">Add Item</button>
        </div>
    </div>
    
    <!-- Search Section -->
    <div class="search-section">
        <div class="search-title">
            üîç Search Items
        </div>
        <div class="search-container">
            <input 
                type="text" 
                id="searchInput" 
                class="search-input" 
                placeholder="Search across all sections..."
                oninput="searchItems()"
            >
            <button class="clear-search" onclick="clearSearch()" id="clearSearchBtn" style="display: none;">‚úï</button>
        </div>
        <div class="search-results" id="searchResults"></div>
    </div>
    
    <!-- Sections Container -->
    <div id="sectionsContainer">
        <!-- Sections will be loaded dynamically here -->
    </div>
    
    <!-- Overall Progress -->
    <div class="overall-progress" id="overallProgressContainer" data-progress="Overall: 0/0 (0%)">
        <div class="progress-fill" id="overallProgressFill"></div>
    </div>
    
    <!-- Buttons -->
    <div class="button-group">
        <button class="collapse-btn" onclick="toggleAllSections()">Collapse/Expand</button>
        <button class="reset-btn" onclick="resetChecklist()">Reset All</button>
    </div>
</div>

<script>
    // GitHub Configuration
    const GITHUB_CONFIG = {
        owner: 'sunilkamathk',
        repo: 'my-checklist',
        token: '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',
        dataFile: 'data.json'
    };
    
    let categories = {};
    let categoryCounter = 3;
    let draggedItem = null;
    let isSyncing = false;
    let syncTimeout = null;
    
    // Default categories and items
    const defaultCategories = {
        1: {
            name: 'üì∏ Photoshoot Day',
            items: ['Selfie stick', 'Balloon', 'Shoe', 'Flower', 'Mirror props', 'Blanket', 'Ultrasound images', 'Chapal sandle']
        },
        2: {
            name: 'üçé Food',
            items: ['Guava', 'Orange', 'Kiwi', 'Yogurt', 'Milk', 'Coffee', 'Tea', 'Sugar', 'Ginger', 'Butter', 'Bread', 'Boiled chana', 'Protein bar', 'Dry fruits', 'Egg', 'Pan', 'Masala', 'Soup', 'Cucumbers', 'Carrot']
        },
        3: {
            name: 'üéí Miscellaneous',
            items: ['Cloths', 'Toothbrush', 'Makeup kit', 'Prenatal iron', 'Soda', 'Coke', 'Paper plates', 'Onion', 'Lemon', 'Tomato', 'Cheese slices', 'Snacks', 'Socks', 'Rumal', 'Jackets']
        }
    };
    
    // Update sync status
    function updateSyncStatus(message, type = 'success') {
        const statusEl = document.getElementById('syncStatus');
        statusEl.textContent = message;
        statusEl.className = 'sync-status';
        
        if (type === 'syncing') {
            statusEl.classList.add('syncing');
        } else if (type === 'error') {
            statusEl.classList.add('error');
        }
    }
    
    // Load data from GitHub
    async function loadFromGitHub() {
        try {
            updateSyncStatus('üîÑ Loading from GitHub...', 'syncing');
            
            const response = await fetch(
                `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${GITHUB_CONFIG.dataFile}`,
                {
                    headers: {
                        'Authorization': `token ${GITHUB_CONFIG.token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                }
            );
            
            if (!response.ok) {
                if (response.status === 404) {
                    loadDefaultData();
                    await saveToGitHub(true);
                    return;
                }
                throw new Error(`GitHub API error: ${response.status}`);
            }
            
            const data = await response.json();
            const content = JSON.parse(atob(data.content));
            
            localStorage.setItem('github_sha', data.sha);
            
            if (content.categories) {
                categories = content.categories;
                categoryCounter = content.categoryCounter || 3;
                renderAllSections();
                updateCategorySelect();
                
                const lastUpdated = content.lastUpdated ? new Date(content.lastUpdated).toLocaleString() : 'Unknown';
                updateSyncStatus(`‚úÖ Synced (Last: ${lastUpdated})`);
            } else {
                loadDefaultData();
                await saveToGitHub(true);
            }
        } catch (error) {
            console.error('Error loading from GitHub:', error);
            updateSyncStatus('‚ùå Sync failed - using local data', 'error');
            
            const saved = localStorage.getItem('categories');
            if (saved) {
                categories = JSON.parse(saved);
                renderAllSections();
                updateCategorySelect();
            } else {
                loadDefaultData();
            }
        }
    }
    
    // Save data to GitHub
    async function saveToGitHub(isInitial = false) {
        if (isSyncing) return;
        
        try {
            isSyncing = true;
            updateSyncStatus('üîÑ Saving to GitHub...', 'syncing');
            
            const dataToSave = {
                categories: categories,
                categoryCounter: categoryCounter,
                lastUpdated: new Date().toISOString()
            };
            
            const content = btoa(JSON.stringify(dataToSave, null, 2));
            const sha = localStorage.getItem('github_sha');
            
            const body = {
                message: isInitial ? 'Initial checklist data' : `Update checklist - ${new Date().toLocaleString()}`,
                content: content
            };
            
            if (sha && !isInitial) {
                body.sha = sha;
            }
            
            const response = await fetch(
                `https://api.github.com/repos/${GITHUB_CONFIG.owner}/${GITHUB_CONFIG.repo}/contents/${GITHUB_CONFIG.dataFile}`,
                {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${GITHUB_CONFIG.token}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                }
            );
            
            if (!response.ok) {
                throw new Error(`GitHub API error: ${response.status}`);
            }
            
            const result = await response.json();
            localStorage.setItem('github_sha', result.content.sha);
            localStorage.setItem('categories', JSON.stringify(categories));
            
            updateSyncStatus('‚úÖ Synced successfully');
        } catch (error) {
            console.error('Error saving to GitHub:', error);
            updateSyncStatus('‚ùå Sync failed - saved locally', 'error');
            localStorage.setItem('categories', JSON.stringify(categories));
        } finally {
            isSyncing = false;
        }
    }
    
    // Debounced save function
    function debouncedSave() {
        if (syncTimeout) {
            clearTimeout(syncTimeout);
        }
        syncTimeout = setTimeout(() => {
            saveToGitHub();
        }, 2000);
    }
    
    // Load default data
    function loadDefaultData() {
        categories = {};
        Object.keys(defaultCategories).forEach(catId => {
            categories[catId] = {
                name: defaultCategories[catId].name,
                items: defaultCategories[catId].items.map((itemName, index) => ({
                    id: `c${catId}-item${index + 1}`,
                    name: itemName,
                    checked: false
                }))
            };
        });
        renderAllSections();
        updateCategorySelect();
    }
    
    // Render all sections
    function renderAllSections() {
        const container = document.getElementById('sectionsContainer');
        container.innerHTML = '';
        
        Object.keys(categories).forEach(catId => {
            const section = createSectionElement(catId);
            container.appendChild(section);
        });
        
        updateAllProgress();
        initializeDragAndDrop();
    }
    
    // Create section element
    function createSectionElement(catId) {
        const category = categories[catId];
        const section = document.createElement('div');
        section.className = 'section';
        section.id = `section${catId}`;
        section.setAttribute('data-section', catId);
        
        const checkedCount = category.items.filter(item => item.checked).length;
        const totalCount = category.items.length;
        const percentage = totalCount > 0 ? Math.round((checkedCount / totalCount) * 100) : 0;
        
        section.innerHTML = `
            <div class="section-header">
                <div class="section-title-container">
                    <h2 id="sectionTitle${catId}">${category.name}</h2>
                    <div class="section-actions">
                        <button class="section-edit-btn" onclick="editCategory('${catId}')">‚úé</button>
                        <button class="section-delete-btn" onclick="deleteCategory('${catId}')">√ó</button>
                    </div>
                </div>
                <span class="section-progress" id="progress${catId}">${checkedCount}/${totalCount}</span>
            </div>
            <div class="section-progress-bar ${percentage > 0 ? 'has-progress' : ''}" id="progressBarContainer${catId}" data-progress="${percentage}%">
                <div class="section-progress-fill" id="progressBar${catId}" style="width: ${percentage}%"></div>
            </div>
            <ul class="checklist" id="checklist${catId}">
            </ul>
        `;
        
        const checklist = section.querySelector(`#checklist${catId}`);
        const sortedItems = [...category.items].sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()));
        
        sortedItems.forEach(item => {
            checklist.appendChild(createItemElement(item, catId));
        });
        
        return section;
    }
    
    // Create item element
    function createItemElement(item, catId) {
        const li = document.createElement('li');
        li.className = 'checklist-item';
        if (item.checked) {
            li.classList.add('checked');
        }
        li.draggable = true;
        li.innerHTML = `
            <span class="drag-handle">‚ãÆ‚ãÆ</span>
            <input type="checkbox" id="${item.id}" data-item="${item.id}" ${item.checked ? 'checked' : ''}>
            <label for="${item.id}">${item.name}</label>
        `;
        
        const checkbox = li.querySelector('input[type="checkbox"]');
        checkbox.addEventListener('change', function() {
            const category = categories[catId];
            const itemObj = category.items.find(i => i.id === item.id);
            if (itemObj) {
                itemObj.checked = this.checked;
            }
            this.parentElement.classList.toggle('checked', this.checked);
            updateAllProgress();
            debouncedSave();
        });
        
        li.addEventListener('dragstart', handleDragStart);
        li.addEventListener('dragend', handleDragEnd);
        
        return li;
    }
    
    // Add new category
    function addNewCategory() {
        const categoryName = document.getElementById('newCategoryName').value.trim();
        
        if (!categoryName) {
            alert('Please enter a category name!');
            return;
        }
        
        categoryCounter++;
        const newCatId = String(categoryCounter);
        
        categories[newCatId] = {
            name: categoryName,
            items: []
        };
        
        const container = document.getElementById('sectionsContainer');
        container.appendChild(createSectionElement(newCatId));
        
        updateCategorySelect();
        document.getElementById('newCategoryName').value = '';
        
        updateAllProgress();
        debouncedSave();
        initializeDragAndDrop();
    }
    
    // Edit category
    function editCategory(catId) {
        const titleElement = document.getElementById(`sectionTitle${catId}`);
        const actionsContainer = titleElement.nextElementSibling;
        
        const currentName = titleElement.textContent;
        
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'section-title-input';
        input.value = currentName;
        
        titleElement.style.display = 'none';
        titleElement.parentNode.insertBefore(input, titleElement);
        
        actionsContainer.innerHTML = `
            <button class="section-save-btn" onclick="saveCategoryEdit('${catId}')">‚úì</button>
            <button class="section-cancel-btn" onclick="cancelCategoryEdit('${catId}')">‚úï</button>
        `;
        
        input.focus();
        input.select();
        
        input.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                saveCategoryEdit(catId);
            }
        });
        
        input.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                cancelCategoryEdit(catId);
            }
        });
    }
    
    // Save category edit
    function saveCategoryEdit(catId) {
        const titleElement = document.getElementById(`sectionTitle${catId}`);
        const input = titleElement.previousElementSibling;
        const actionsContainer = titleElement.nextElementSibling;
        
        const newName = input.value.trim();
        
        if (!newName) {
            alert('Category name cannot be empty!');
            input.focus();
            return;
        }
        
        categories[catId].name = newName;
        titleElement.textContent = newName;
        titleElement.style.display = '';
        input.remove();
        
        actionsContainer.innerHTML = `
            <button class="section-edit-btn" onclick="editCategory('${catId}')">‚úé</button>
            <button class="section-delete-btn" onclick="deleteCategory('${catId}')">√ó</button>
        `;
        
        updateCategorySelect();
        debouncedSave();
    }
    
    // Cancel category edit
    function cancelCategoryEdit(catId) {
        const titleElement = document.getElementById(`sectionTitle${catId}`);
        const input = titleElement.previousElementSibling;
        const actionsContainer = titleElement.nextElementSibling;
        
        titleElement.style.display = '';
        input.remove();
        
        actionsContainer.innerHTML = `
            <button class="section-edit-btn" onclick="editCategory('${catId}')">‚úé</button>
            <button class="section-delete-btn" onclick="deleteCategory('${catId}')">√ó</button>
        `;
    }
    
    // Delete category
    function deleteCategory(catId) {
        const category = categories[catId];
        if (confirm(`Delete category "${category.name}" and all its items?`)) {
            delete categories[catId];
            document.getElementById(`section${catId}`).remove();
            updateCategorySelect();
            updateAllProgress();
            debouncedSave();
        }
    }
    
    // Update category select dropdown
    function updateCategorySelect() {
        const select = document.getElementById('sectionSelect');
        select.innerHTML = '';
        
        Object.keys(categories).forEach(catId => {
            const option = document.createElement('option');
            option.value = catId;
            option.textContent = categories[catId].name;
            select.appendChild(option);
        });
    }
    
    // Add new item
    function addNewItem() {
        const itemName = document.getElementById('newItemName').value.trim();
        const catId = document.getElementById('sectionSelect').value;
        
        if (!itemName) {
            alert('Please enter an item name!');
            return;
        }
        
        if (!catId || !categories[catId]) {
            alert('Please select a valid category!');
            return;
        }
        
        const category = categories[catId];
        const itemCounter = category.items.length + 1;
        const itemId = `c${catId}-item${itemCounter}`;
        
        const newItem = {
            id: itemId,
            name: itemName,
            checked: false
        };
        
        category.items.push(newItem);
        
        const checklist = document.getElementById(`checklist${catId}`);
        checklist.appendChild(createItemElement(newItem, catId));
        
        sortSectionItems(catId);
        
        document.getElementById('newItemName').value = '';
        
        updateAllProgress();
        debouncedSave();
        initializeDragAndDrop();
    }
    
    // Sort section items
    function sortSectionItems(catId) {
        const checklist = document.getElementById(`checklist${catId}`);
        const items = Array.from(checklist.querySelectorAll('.checklist-item'));
        
        items.sort((a, b) => {
            const labelA = a.querySelector('label').textContent.toLowerCase();
            const labelB = b.querySelector('label').textContent.toLowerCase();
            return labelA.localeCompare(labelB);
        });
        
        checklist.innerHTML = '';
        items.forEach(item => checklist.appendChild(item));
    }
    
    // Search functionality
    function searchItems() {
        const searchTerm = document.getElementById('searchInput').value.toLowerCase().trim();
        const clearBtn = document.getElementById('clearSearchBtn');
        const searchResults = document.getElementById('searchResults');
        
        clearBtn.style.display = searchTerm ? 'block' : 'none';
        
        if (!searchTerm) {
            document.querySelectorAll('.checklist-item').forEach(item => {
                item.classList.remove('hidden', 'highlight');
            });
            searchResults.textContent = '';
            searchResults.className = 'search-results';
            return;
        }
        
        let matchCount = 0;
        
        document.querySelectorAll('.checklist-item').forEach(item => {
            const label = item.querySelector('label');
            const itemText = label.textContent.toLowerCase();
            
            if (itemText.includes(searchTerm)) {
                item.classList.remove('hidden');
                item.classList.add('highlight');
                matchCount++;
            } else {
                item.classList.add('hidden');
                item.classList.remove('highlight');
            }
        });
        
        if (matchCount > 0) {
            searchResults.textContent = `Found ${matchCount} item${matchCount !== 1 ? 's' : ''} matching "${searchTerm}"`;
            searchResults.className = 'search-results active';
        } else {
            searchResults.textContent = `No items found matching "${searchTerm}"`;
            searchResults.className = 'search-results no-results';
        }
    }
    
    function clearSearch() {
        document.getElementById('searchInput').value = '';
        searchItems();
    }
    
    // Drag and drop handlers
    function initializeDragAndDrop() {
        const items = document.querySelectorAll('.checklist-item');
        items.forEach(item => {
            item.addEventListener('dragstart', handleDragStart);
            item.addEventListener('dragend', handleDragEnd);
        });
        
        const sections = document.querySelectorAll('.section');
        sections.forEach(section => {
            const checklist = section.querySelector('.checklist');
            checklist.addEventListener('dragover', handleDragOver);
            checklist.addEventListener('drop', handleDrop);
            checklist.addEventListener('dragleave', handleDragLeave);
        });
    }
    
    function handleDragStart(e) {
        draggedItem = this;
        this.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData('text/html', this.innerHTML);
    }
    
    function handleDragEnd(e) {
        this.classList.remove('dragging');
        document.querySelectorAll('.section').forEach(section => {
            section.classList.remove('drag-over');
        });
    }
    
    function handleDragOver(e) {
        if (e.preventDefault) {
            e.preventDefault();
        }
        
        e.dataTransfer.dropEffect = 'move';
        const section = this.closest('.section');
        section.classList.add('drag-over');
        
        return false;
    }
    
    function handleDragLeave(e) {
        const section = this.closest('.section');
        if (e.target === this) {
            section.classList.remove('drag-over');
        }
    }
    
    function handleDrop(e) {
        if (e.stopPropagation) {
            e.stopPropagation();
        }
        
        const section = this.closest('.section');
        section.classList.remove('drag-over');
        
        if (draggedItem && draggedItem !== this) {
            const targetCatId = section.getAttribute('data-section');
            const oldCheckbox = draggedItem.querySelector('input[type="checkbox"]');
            const oldId = oldCheckbox.id;
            const label = draggedItem.querySelector('label');
            const itemName = label.textContent;
            
            // Find and remove from old category
            let oldCatId = null;
            for (const catId in categories) {
                const itemIndex = categories[catId].items.findIndex(item => item.id === oldId);
                if (itemIndex !== -1) {
                    const item = categories[catId].items[itemIndex];
                    const isChecked = item.checked;
                    
                    // Remove from old category
                    categories[catId].items.splice(itemIndex, 1);
                    oldCatId = catId;
                    
                    // Add to new category
                    const newItemCounter = categories[targetCatId].items.length + 1;
                    const newId = `c${targetCatId}-item${newItemCounter}`;
                    
                    categories[targetCatId].items.push({
                        id: newId,
                        name: itemName,
                        checked: isChecked
                    });
                    
                    break;
                }
            }
            
            // Re-render affected sections
            if (oldCatId) {
                const oldSection = document.getElementById(`section${oldCatId}`);
                if (oldSection) {
                    const newOldSection = createSectionElement(oldCatId);
                    oldSection.replaceWith(newOldSection);
                }
            }
            
            const newSection = createSectionElement(targetCatId);
            section.replaceWith(newSection);
            
            updateAllProgress();
            debouncedSave();
            initializeDragAndDrop();
            
            const searchTerm = document.getElementById('searchInput').value;
            if (searchTerm) {
                searchItems();
            }
        }
        
        return false;
    }
    
    // Update progress
    function updateSectionProgress(catId) {
        const category = categories[catId];
        if (!category) return;
        
        const total = category.items.length;
        const checked = category.items.filter(item => item.checked).length;
        const percentage = total > 0 ? Math.round((checked / total) * 100) : 0;
        
        const progressText = document.getElementById(`progress${catId}`);
        const progressBar = document.getElementById(`progressBar${catId}`);
        const progressBarContainer = document.getElementById(`progressBarContainer${catId}`);
        
        if (progressText) progressText.textContent = `${checked}/${total}`;
        if (progressBar) progressBar.style.width = percentage + '%';
        if (progressBarContainer) {
            progressBarContainer.setAttribute('data-progress', percentage + '%');
            if (percentage > 0) {
                progressBarContainer.classList.add('has-progress');
            } else {
                progressBarContainer.classList.remove('has-progress');
            }
        }
    }
    
    function updateOverallProgress() {
        let totalItems = 0;
        let checkedItems = 0;
        
        Object.values(categories).forEach(category => {
            totalItems += category.items.length;
            checkedItems += category.items.filter(item => item.checked).length;
        });
        
        const percentage = totalItems > 0 ? Math.round((checkedItems / totalItems) * 100) : 0;
        
        const progressFill = document.getElementById('overallProgressFill');
        const progressContainer = document.getElementById('overallProgressContainer');
        
        if (progressFill) progressFill.style.width = percentage + '%';
        if (progressContainer) {
            const progressText = `Overall: ${checkedItems}/${totalItems} (${percentage}%)`;
            progressContainer.setAttribute('data-progress', progressText);
            
            if (percentage > 0) {
                progressContainer.classList.add('has-progress');
            } else {
                progressContainer.classList.remove('has-progress');
            }
        }
    }
    
    function updateAllProgress() {
        Object.keys(categories).forEach(catId => {
            updateSectionProgress(catId);
        });
        updateOverallProgress();
    }
    
    // Toggle all sections
    function toggleAllSections() {
        const sections = document.querySelectorAll('.section');
        const firstSection = sections[0];
        const isCollapsed = firstSection.classList.contains('collapsed');
        
        sections.forEach(section => {
            if (isCollapsed) {
                section.classList.remove('collapsed');
            } else {
                section.classList.add('collapsed');
            }
        });
    }
    
    // Reset checklist
    function resetChecklist() {
        if (confirm('Are you sure you want to reset the entire checklist? This will uncheck all items but keep all categories and item names.')) {
            Object.values(categories).forEach(category => {
                category.items.forEach(item => {
                    item.checked = false;
                });
            });
            
            renderAllSections();
            debouncedSave();
        }
    }
    
    // Update date and time
    function updateDateTime() {
        const now = new Date();
        const options = { 
            weekday: 'short', 
            year: 'numeric', 
            month: 'short', 
            day: 'numeric'
        };
        const dateStr = now.toLocaleDateString('en-US', options);
        const timeStr = now.toLocaleTimeString('en-US', { 
            hour: '2-digit', 
            minute: '2-digit',
            second: '2-digit'
        });
        
        document.getElementById('currentDate').textContent = dateStr;
        document.getElementById('currentTime').textContent = timeStr;
    }
    
    // Initialize on page load
    updateDateTime();
    setInterval(updateDateTime, 1000);
    
    loadFromGitHub();
    
    // Auto-sync every 5 minutes
    setInterval(() => {
        if (!isSyncing) {
            loadFromGitHub();
        }
    }, 300000);
</script>
</body>
</html>
